//we need this to use
   if ("taskOutput" in argument) {
            const taskOutput = argument.taskOutput;
            const edge: Edge = {
              id: `${taskOutput.taskId}_${taskOutput.outputName}-${taskId}_${inputName}`,
              source: taskOutput.taskId,
              sourceHandle: `output_${taskOutput.outputName}`,
              target: taskId,
              targetHandle: `input_${inputName}`,
              arrowHeadType: ArrowHeadType.ArrowClosed,
            };
            return [edge];
          }


//update nodeData

 const handleUpdateNodeData = (data) => {
    setOpen(false);
    const selectedIds = [];
    if (!selectedElements) return; // Stop if selected elements is empty
    for (const elm of selectedElements) {
      selectedIds.push(elm.id);
    }
    for (const elmMap of yDoc.current.getArray('elements')) {
      if (selectedIds.includes(elmMap.get('id')) && ['ShapeNode', 'HandleNode'].includes(elmMap.get('type'))) {
        elmMap.set('data', {...elmMap.get('data'), ...data});
      }
    }
  }

  //save on LocalStorage and restore

    const { transform } = useZoomPanHelper();

  const onSave = useCallback(() => {
    if (rfInstance) {
      const flow = rfInstance.toObject();
      localforage.setItem(flowKey, flow);
    }
  }, [rfInstance]);

  const onRestore = useCallback(() => {
    const restoreFlow = async () => {
      const flow = await localforage.getItem(flowKey);

      if (flow) {
        const [x = 0, y = 0] = flow.position;
        setElements(flow.elements || []);
        transform({ x, y, zoom: flow.zoom || 0 });
      }
    };

    restoreFlow();
  }, [setElements, transform]);

  https://reactflow.dev/examples/save-and-restore/



    <Grid container>
                <Grid item md={4}>
                  <TextField
                    inputRef={labelRef}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        handleUpdateNodeData(labelRef.current.value);
                        setinputData(labelRef.current.value);
                        setOpenElementClick(false);
                        setPendingRequest(true);
                      }
                    }}
                    className={classes.nodetext}
                    id='outlined-basic'
                    multiline
                    label='Write node text'
                    variant='filled'
                  />
                </Grid>
                <Grid item md={4}>
                  <TextField
                    inputRef={labelRef}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        handleUpdateNodeData(labelRef.current.value);
                        setinputData(labelRef.current.value);
                        setOpenElementClick(false);
                        setPendingRequest(true);
                      }
                    }}
                    className={classes.nodetext}
                    id='outlined-basic'
                    multiline
                    label='Write node text'
                    variant='filled'
                  />
                </Grid>
                <Grid item md={4}>
                  <TextField
                    inputRef={labelRef}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        handleUpdateNodeData(labelRef.current.value);
                        setinputData(labelRef.current.value);
                        setOpenElementClick(false);
                        setPendingRequest(true);
                      }
                    }}
                    className={classes.nodetext}
                    id='outlined-basic'
                    multiline
                    label='Write node text'
                    variant='filled'
                  />
                </Grid>
                <Button
                  className={classes.buttonForTable}
                  variant='contained'
                  color='primary'
                  type='submit'
                  // onClick={() => setOpenClickWayListener(!openClickWayListener)}
                >
                  Save
                </Button>
              </Grid>










              import React, { useEffect, useState } from 'react';
import SockJsClient from 'react-stomp';
import { useSelector } from 'react-redux';
import { BACKEND_WEBSOCKET_URL } from '../../urlConfig';
import Modal from '../../Components/Reusable/Modal';
import { Typography } from '@material-ui/core';
const WebSocks = (props) => {
  const user = useSelector((state) => state.auth);

  const [invisible, setInVisible] = useState(true);
  const [modal, setModal] = useState(false);
  const [refData, setRefData] = useState(null);
  const { organizationId, id } = user?.user;
  const { elements, setPendingRequest, pendingRequest } = props;
  const sendMessage = () => {
    if (pendingRequest) {
      refData.sendMessage(
        '/app/organization',
        JSON.stringify({
          userId: id,
          organizationId: organizationId,
          messageContent: elements,
        })
      );
    }
  };

  useEffect(() => {
    sendMessage();
    setPendingRequest(false);
  }, [pendingRequest]);

  const handleMessage = (msg) => {
    props.setElements(msg.messageContent);
  };
  const newConnectedModal = () => {
    return (
      <Modal open={modal} handleClose={() => setModal(false)}>
        <Typography style={{ padding: '60px' }} variant='h5' component='h2'>
          Socket Disconnected
        </Typography>
      </Modal>
    );
  };
  return (
    <div>
      <SockJsClient
        url={BACKEND_WEBSOCKET_URL + '/push-message-mapping/'}
        topics={['/topic/content/' + organizationId]}
        onConnect={() => {
          setInVisible(false);
        }}
        onDisconnect={() => {
          setModal(true);
          // setInVisible(true);
        }}
        onMessage={(msg) => {
          handleMessage(msg);
        }}
        ref={(client) => {
          setRefData(client);
        }}
      />
      {modal && newConnectedModal()}
      {invisible && newConnectedModal()}
    </div>
  );
};

export default WebSocks;





  function generateCSV() {
    if (elements) {
      const newValueStream = valueStream.map((item) => {
        return elements.filter(
          (item1) => item1.data.valueStreamId == item.id && item1.data
        );
      });
      console.log({ newValueStream });
      const newValueStreamFilter = valueStream.map((item, index) => {
        const newObj = {
          valueStreamId: item.id,
          elementsDtoList: newValueStream[index],
          valueStreamName: item.valueStreamName,
          valueStreamWhy: item.valueStreamWhy,
          persona: item.persona,
        };
        return newObj;
      });
      //to save the JSON
      // saveFlow(newValueStreamFilter, nanoid, setOpenMenuClick);
      // const mapedElements = elements.some((item) => item.type === "end");
      // // setEpicList()
      // if (mapedElements) {
      //   dispatch(
      //     sendValueStreamAndDiagramForCSV(newValueStreamFilter, organizationId)
      //   );
      //   setOpenMenuClick(false);
      // } else {
      //   setErrorMessage("Please Add EndNode To Execute Algorithm");
      // }

      // if (mapedElements) {
      //   dispatch(sendValueStreamAndDiagramForCSV(elements, organizationId));
      //   setOpenMenuClick(false);
      // } else {
      //   setErrorMessage("Please Add EndNode To Execute Algorithm");
      // }
    }
  }


 {/* <TextField
            style={{ margin: "20px" }}
            variant="outlined"
            defaultValue={valueStream.length > 0 ? valueStream[0]?.persona : ""}
            label="Persona"
            InputProps={{
              readOnly: valueStream.length > 0 ? true : false,
            }}
            placeholder="your Persona Name"
            {...register("persona", {
              required: true,
              maxLength: 20,
            })}
          /> */}

import axios from "../../api/axios";
import { authConstants } from "./constant";

export const login = (user) => {

  //check this part
  return async (dispatch) => {
    dispatch({ type: authConstants.LOGIN_REQUEST });
    const res = await axios.post("/v1/users/login", {
      ...user,
    });

    if (res.status === 200) {
      const { token, user } = res.data;
      localStorage.setItem("sqtoken", JSON.stringify(token));
      localStorage.setItem("squser", JSON.stringify(user));
      dispatch({
        type: authConstants.LOGIN_SUCCESS,
        payload: {
          token,
          user,
        },
      });
    } else {
      if (res.status === 400) {
        dispatch({
          type: authConstants.LOGIN_FAILURE,
          payload: { error: res.data.error },
        });
      }
    }
  };
};

export const isUserLoggedIn = () => {
  return async (dispatch) => {
    const token = window.localStorage.getItem("sqtoken");

    if (token) {
      const user = JSON.parse(window.localStorage.getItem("squser"));
      dispatch({
        type: authConstants.LOGIN_SUCCESS,
        payload: {
          token,
          user,
        },
      });
    } else {
      dispatch({
        type: authConstants.LOGIN_FAILURE,
        payload: { error: "Need to login" },
      });
    }
  };
};

export const signout = () => {
  return async (dispatch) => {
    window.localStorage.removeItem("sqtoken");
    window.localStorage.removeItem("squser");
    dispatch({
      type: authConstants.LOGOUT_SUCCESS,
      payload: "Success"
    });
  };
};

// export const signout = () => {
//   return async (dispatch) => {
//     dispatch({
//       type: authConstants.LOGOUT_REQUEST,
//     });

//     try {
//       const res = await axios.get("/v1/users/logout");
//       if (res.status === 200) {
//         window.localStorage.removeItem("sqtoken");
//         window.localStorage.removeItem("squser");
//         dispatch({
//           type: authConstants.LOGOUT_SUCCESS,
//           payload: res.data
//         });
//       } else {
//         dispatch({
//           type: authConstants.LOGOUT_FAILURE,
//           payload: { error: res.data.error },
//         });
//       }
//     } catch (error) {
//       console.log("signout error", error);
//     }

//   };
// };

